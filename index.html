<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>V2V | Ø¯Ø³ØªØ±Ø³ÛŒ Ø¢Ø²Ø§Ø¯</title>
    <meta name="description" content="Ù¾Ø±ÙˆÚ˜Ù‡â€ŒØ§ÛŒ Ø¨Ø±Ø§ÛŒ ØªØ¬Ù…ÛŒØ¹ Ùˆ Ø§Ø±Ø§Ø¦Ù‡ Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ÛŒ V2Ray Ø¨Ø§ ØªØ³Øª Ø³Ø±Ø¹Øª Ùˆ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯.">
    <meta property="og:title" content="V2V | Ø¯Ø³ØªØ±Ø³ÛŒ Ø¢Ø²Ø§Ø¯ Ùˆ Ù¾Ø§ÛŒØ¯Ø§Ø±" />
    <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <style>
        :root {
            --bg-color: #000000; --card-color: #1e1e1e; --text-color: #e0e0e0;
            --primary-color: #8B0000; --secondary-color: #28a745; --error-color: #cf6679;
            --success-color: #66bb6a; --warning-color: #ffeb3b; --btn-bg: #2a2a2a;
        }
        body { font-family: 'Vazirmatn', sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 20px; }
        main { max-width: 1200px; margin: 0 auto; }
        .site-logo { display: block; margin: 0 auto 15px auto; max-width: 160px; height: auto; }
        .slogan { text-align: center; color: #aaa; font-style: italic; margin-bottom: 2em; font-weight: 600; }
        .info-box { text-align: center; font-weight: bold; margin-bottom: 15px; padding: 15px; border-radius: 8px; background-color: var(--card-color); font-size: 1.1em; }
        
        .core-selector { display: flex; flex-direction: column; gap: 15px; margin: 20px 0; }
        .core-select-btn {
            background-color: var(--primary-color); color: #fff; border: 2px solid var(--primary-color);
            padding: 15px; font-size: 1.1em; font-weight: bold; border-radius: 8px; cursor: pointer;
            font-family: 'Vazirmatn', sans-serif; white-space: nowrap; transition: all 0.2s;
        }
        .core-select-btn:hover { background-color: #6d0000; }

        #btn-xray { background-color: var(--secondary-color); border-color: var(--secondary-color); color: #000; }
        #btn-xray:hover { background-color: #1f7a33; }

        .core-content { display: none; padding: 20px; border: 1px solid #333; border-radius: 8px; margin-top: 10px; }
        .speed-test-btn { background-color: var(--secondary-color); color: #000; border: none; padding: 12px 24px; border-radius: 6px; font-size: 1.1em; cursor: pointer; display: block; width: 100%; margin-bottom: 25px; font-weight: bold; }
        .speed-test-btn:disabled { background-color: #555; cursor: not-allowed; }
        
        .links-container { background-color: var(--card-color); padding: 20px; border-radius: 8px; text-align: center; margin-bottom: 25px; }
        .links-container h3 { margin-top: 0; color: var(--secondary-color); border-bottom: 1px solid #444; padding-bottom: 10px; margin-bottom: 20px; }
        .link-group { margin-bottom: 20px; } .link-group:last-child { margin-bottom: 0; }
        .link-group h4 { margin: 0 0 10px 0; color: var(--text-color); }
        .link-buttons { display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; }
        .link-btn { background-color: var(--btn-bg); color: var(--text-color); padding: 10px 15px; border-radius: 5px; text-decoration: none; font-weight: bold; transition: background-color 0.2s; border: 1px solid #444; cursor: pointer; }
        
        .protocol-accordion-item { margin-bottom: 15px; }
        .protocol-accordion-header { background-color: var(--card-color); padding: 15px; cursor: pointer; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; }
        .protocol-accordion-header h3 { margin: 0; color: var(--secondary-color); font-size: 1.2em; }
        .copy-protocol-btn { font-size: 0.8em; padding: 5px 10px; flex-shrink: 0; margin-left: 15px; }
        .protocol-accordion-content { display: none; padding: 20px 5px 5px 5px; }
        .config-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px; }
        .config-card { background-color: var(--card-color); border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); overflow: hidden; display: flex; flex-direction: column; position: relative; }
        .ping-result { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 3px 8px; border-radius: 12px; font-size: 0.8em; font-weight: bold; }
        .ping-result.fast { color: var(--success-color); } .ping-result.slow { color: var(--warning-color); } .ping-result.timeout { color: var(--error-color); }
        .config-details { padding: 15px; flex-grow: 1; }
        .config-name { font-weight: bold; font-size: 1.1em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .actions { display: flex; justify-content: space-around; padding: 10px 15px; background-color: rgba(0,0,0,0.2); }
        .action-btn { background-color: var(--btn-bg); border: 1px solid #444; border-radius: 5px; cursor: pointer; font-weight: bold; padding: 8px 15px; flex-grow: 1; margin: 0 5px; color: var(--text-color); }

        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.8); justify-content: center; align-items: center; }
        .modal-content { background-color: var(--card-color); padding: 20px; border-radius: 8px; width: 90%; max-width: 320px; text-align: center; position: relative; }
        .close-btn { position: absolute; top: 10px; left: 20px; color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; }
        #modal-qr-code { background: white; padding: 10px; border-radius: 4px; margin: 15px auto 0; }
        footer { text-align: center; margin-top: 40px; padding-top: 20px; border-top: 1px solid #333; }
        .footer-links { list-style: none; padding: 0; margin: 0; display: flex; justify-content: center; gap: 25px; }
        .footer-links a { color: var(--secondary-color); text-decoration: none; font-weight: bold; }
    </style>
</head>
<body>
    <main>
        <img src="https://smbcryp.github.io/V2V/logo.png" alt="V2V Logo" class="site-logo">
        <p class="slogan">Ø³Ù¾Ø§Ø³ Ù‡Ø±â€ŒØ¢Ù†Ú©Ù‡ Ø®ÙˆØ§Ù‡ ÛŒØ§ Ù†Ø§Ø®ÙˆØ§Ù‡ Ø¯Ø³ØªÛŒ Ø¨Ø± Ø§ÛŒÙ† Ø±Ø§Ù‡Ú© Ø±Ù‡Ø§ÛŒÛŒ Ø¯Ø§Ø´Øª</p>
        
        <div id="info" class="info-box">Ø¯Ø±Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ...</div>

        <div class="core-selector">
            <button id="btn-xray" class="core-select-btn" style="display: none;">Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ÛŒ Xray-Core</button>
            <div id="content-xray" class="core-content"></div>

            <button id="btn-singbox" class="core-select-btn" style="display: none;">Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ÛŒ Sing-box</button>
            <div id="content-singbox" class="core-content"></div>
        </div>

        <footer>
             <ul class="footer-links">
                <li><a href="https://github.com/SMBCRYP/V2V/" target="_blank">Ú¯ÛŒØªâ€ŒÙ‡Ø§Ø¨</a></li>
                <li><a href="https://v2-v.vercel.app/" target="_blank">ÙˆØ±Ø³Ù„</a></li>
                <li><a href="http://v2v-data.s3-website.ir-thr-at1.arvanstorage.ir" target="_blank">Ø¢Ø±ÙˆØ§Ù†</a></li>
            </ul>
        </footer>
    </main>
    
    <div id="qrModal" class="modal">
        <div class="modal-content"><span class="close-btn">&times;</span><h3 id="modal-title">QR Code</h3><canvas id="modal-qr-code"></canvas></div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // DOM Elements
    const infoContainer = document.getElementById('info');
    const xrayBtn = document.getElementById('btn-xray');
    const singboxBtn = document.getElementById('btn-singbox');
    const xrayContent = document.getElementById('content-xray');
    const singboxContent = document.getElementById('content-singbox');
    const qrModal = document.getElementById('qrModal');
    const modalTitle = document.getElementById('modal-title');
    const modalQrCanvas = document.getElementById('modal-qr-code');
    const closeBtn = document.querySelector('.close-btn');

    // State
    let allConfigs = { xray: [], singbox: [] };
    let testCompleted = { xray: false, singbox: false };

    // --- Configuration ---
    const API_ENDPOINT = '/api/proxy';
    const BATCH_SIZE = 20;
    const CONFIG_SOURCES = [
        `https://cdn.jsdelivr.net/gh/SMBCRYP/V2V@main/all_live_configs.json?v=${Date.now()}`,
        `https://raw.githubusercontent.com/SMBCRYP/V2V/main/all_live_configs.json?v=${Date.now()}`
    ];
    const TOP_N_CONFIGS = 500;

    // --- Dynamic Generation Functions ---
    const generateSubscriptionContent = (configs) => {
        const topConfigs = configs.filter(c => c.ping < 9999).slice(0, TOP_N_CONFIGS);
        return topConfigs.map(c => c.config_str).join('\n');
    };

    const generateClashYaml = (configs) => {
        const fastestConfigs = configs.filter(c => c.ping < 9999).slice(0, TOP_N_CONFIGS);
        if (fastestConfigs.length === 0) return null;

        const proxies = [];
        const proxyNames = new Set();

        fastestConfigs.forEach((cfg, index) => {
            try {
                let name = (decodeURIComponent(new URL(cfg.config_str).hash.substring(1)) || `V2V-${cfg.core}-${index}`).trim();
                let originalName = name;
                let counter = 1;
                while (proxyNames.has(name)) {
                    name = `${originalName} (${counter++})`;
                }
                proxyNames.add(name);
                
                const parsed = new URL(cfg.config_str);
                const params = new URLSearchParams(parsed.search);
                let proxy_obj = {
                    name: name, type: parsed.protocol.replace(':', ''),
                    server: parsed.hostname, port: parseInt(parsed.port), udp: true
                };

                if (proxy_obj.type === 'vless') {
                    proxy_obj.uuid = parsed.username;
                    proxy_obj.network = params.get('type') || 'ws';
                    proxy_obj.tls = params.get('security') === 'tls' || params.get('security') === 'reality';
                    proxy_obj.servername = params.get('sni') || parsed.hostname;
                    if (proxy_obj.network === 'ws') {
                        proxy_obj['ws-opts'] = { path: params.get('path') || '/', headers: { Host: params.get('host') || proxy_obj.servername } };
                    }
                    if (params.get('security') === 'reality') {
                        proxy_obj['client-fingerprint'] = params.get('fp') || 'chrome';
                        proxy_obj['reality-opts'] = { 'public-key': params.get('pbk'), 'short-id': params.get('sid') || '' };
                    }
                } else if (proxy_obj.type === 'vmess') {
                    const b64 = parsed.hostname + '='.repeat((-parsed.hostname.length) % 4);
                    const decoded = JSON.parse(atob(b64));
                    proxy_obj.uuid = decoded.id;
                    proxy_obj.alterId = decoded.aid || 0;
                    proxy_obj.cipher = decoded.scy || 'auto';
                    proxy_obj.tls = decoded.tls === 'tls';
                    proxy_obj.servername = decoded.sni || decoded.host || proxy_obj.server;
                    proxy_obj.network = decoded.net || 'ws';
                    if (proxy_obj.network === 'ws') {
                        proxy_obj['ws-opts'] = { path: decoded.path || '/', headers: { Host: decoded.host || proxy_obj.server }};
                    }
                } else if (proxy_obj.type === 'trojan') {
                    proxy_obj.password = parsed.username;
                    proxy_obj.sni = params.get('sni') || parsed.hostname;
                }
                proxies.push(proxy_obj);
            } catch (e) { console.error("Failed to parse config for Clash:", cfg.config_str, e); }
        });

        const clashConfig = {
            'port': 7890, 'socks-port': 7891, 'allow-lan': true, 'mode': 'rule',
            'log-level': 'info', 'external-controller': '0.0.0.0:9090', 'proxies': proxies,
            'proxy-groups': [
                { 'name': `V2V-Auto ğŸš€`, 'type': 'url-test', 'proxies': Array.from(proxyNames), 'url': 'http://www.gstatic.com/generate_204', 'interval': 300 },
                { 'name': 'V2V-Select é¸æŠ', 'type': 'select', 'proxies': [`V2V-Auto ğŸš€`, ...Array.from(proxyNames)] }
            ],
            'rules': [ 'DOMAIN-SUFFIX,ir,DIRECT', 'GEOIP,IR,DIRECT', 'MATCH,V2V-Select é¸æŠ' ]
        };
        return jsyaml.dump(clashConfig);
    };

    // --- Helper Functions ---
    const showCopyFeedback = (element, originalText) => {
        element.textContent = "âœ… Ú©Ù¾ÛŒ Ø´Ø¯";
        setTimeout(() => { element.textContent = originalText; }, 2000);
    };

    const openQrModal = (url, title) => {
        modalTitle.textContent = title;
        QRCode.toCanvas(modalQrCanvas, url, { width: 280, margin: 1 });
        qrModal.style.display = "flex";
    };
    
    const copyToClipboard = async (text, element) => {
        try {
            await navigator.clipboard.writeText(text);
            showCopyFeedback(element, element.textContent);
        } catch (err) { alert('Ú©Ù¾ÛŒ Ú©Ø±Ø¯Ù† Ø¨Ø§ Ø®Ø·Ø§ Ù…ÙˆØ§Ø¬Ù‡ Ø´Ø¯.'); }
    };
    
    const robustParseServerDetails = (configUrl) => {
        try {
            // Handle SS protocol separately as it doesn't follow standard URL format
            if (configUrl.startsWith('ss://')) {
                const atIndex = configUrl.lastIndexOf('@');
                if (atIndex === -1) return null;
                const hostPart = configUrl.substring(atIndex + 1, configUrl.includes('#') ? configUrl.lastIndexOf('#') : undefined);
                const colonIndex = hostPart.lastIndexOf(':');
                if (colonIndex === -1) return null;
                const host = hostPart.substring(0, colonIndex);
                const port = parseInt(hostPart.substring(colonIndex + 1));
                return { host, port };
            }
            // Standard URL parsing for others
            const url = new URL(configUrl);
            if (url.protocol === 'vmess:') {
                const b64 = url.hostname + '='.repeat((-url.hostname.length) % 4);
                const decoded = JSON.parse(atob(b64));
                return { host: decoded.add, port: parseInt(decoded.port) };
            }
            return { host: url.hostname, port: parseInt(url.port) };
        } catch (e) {
            console.error(`Parsing failed for: ${configUrl}`, e);
            return null;
        }
    };


    const extractNameFromUrl = (url) => {
        try {
            return decodeURIComponent(new URL(url).hash.substring(1)) || new URL(url).hostname;
        } catch { return url.substring(0, 30) + '...'; }
    };
    
    const startClientSideBatchTest = async (coreName, btnElement) => {
        const configsToTest = allConfigs[coreName];
        if (!configsToTest || configsToTest.length === 0) return;

        btnElement.disabled = true;
        testCompleted[coreName] = false;
        let testedCount = 0;

        for (let i = 0; i < configsToTest.length; i += BATCH_SIZE) {
            const batch = configsToTest.slice(i, i + BATCH_SIZE);
            const promises = batch.map(config => {
                const details = robustParseServerDetails(config.config_str);
                if (!details) {
                    return Promise.resolve({ configId: config.id, ping: 9999, error: 'Parse Error' });
                }
                
                return fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ host: details.host, port: details.port })
                })
                .then(res => res.ok ? res.json() : res.json().then(err => Promise.reject(err)))
                .then(data => ({ configId: config.id, ping: data.ping, error: data.error }))
                .catch(() => ({ configId: config.id, ping: 9999, error: 'Network Error' }));
            });

            const results = await Promise.all(promises);
            
            results.forEach(result => {
                const { configId, ping, error } = result;
                const configIndex = configsToTest.findIndex(c => c.id === configId);
                if (configIndex > -1) configsToTest[configIndex].ping = ping;
                
                const card = document.querySelector(`.config-card[data-config-id="${configId}"]`);
                if (card) {
                    const pingEl = card.querySelector('.ping-result');
                    const pingText = error ? (error === 'Timeout' ? 'Timeout' : 'Error') : `${ping}ms`;
                    pingEl.textContent = pingText;
                    pingEl.className = 'ping-result';
                    if (error || ping >= 9999) pingEl.classList.add('timeout');
                    else if (ping < 400) pingEl.classList.add('fast');
                    else pingEl.classList.add('slow');
                }
            });

            testedCount += batch.length;
            const progress = Math.round((testedCount / configsToTest.length) * 100);
            btnElement.textContent = `... Ø¯Ø± Ø­Ø§Ù„ ØªØ³Øª ${progress}%`;
        }
        
        configsToTest.sort((a, b) => (a.ping || 9999) - (b.ping || 9999));
        const containerId = coreName === 'xray' ? '#content-xray' : '#content-singbox';
        renderProtocolAccordions(configsToTest, document.querySelector(`${containerId} .protocol-container`));

        btnElement.textContent = `ğŸš€ ØªØ³Øª Ø³Ø±Ø¹Øª Ù…Ø¬Ø¯Ø¯`;
        btnElement.disabled = false;
        testCompleted[coreName] = true;
        infoContainer.textContent = `ØªØ³Øª Ú©Ø§Ù…Ù„ Ø´Ø¯. Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø³Ø±Ø¹Øª ÙˆØ§Ù‚Ø¹ÛŒ Ø´Ù…Ø§ Ù…Ø±ØªØ¨ Ø´Ø¯Ù†Ø¯.`;
    };

    // --- Render Functions ---
    const createConfigCard = (cfg) => {
        const card = document.createElement('div');
        card.className = 'config-card';
        card.dataset.configId = cfg.id;

        card.innerHTML = `
            <div class="ping-result">...</div>
            <div class="config-details"><div class="config-name" title="${cfg.name}">${cfg.name}</div></div>
            <div class="actions">
                <button class="action-btn copy-btn">Ú©Ù¾ÛŒ</button>
                <button class="action-btn qr-btn">QR</button>
            </div>`;
        
        card.querySelector('.copy-btn').onclick = (e) => copyToClipboard(cfg.config_str, e.target);
        card.querySelector('.qr-btn').onclick = () => openQrModal(cfg.config_str, cfg.name);
        return card;
    };

    const renderProtocolAccordions = (configs, container) => {
        container.innerHTML = '';
        const getProtocol = (cfg) => {
             const proto = cfg.config_str.split('://')[0].toLowerCase();
             if (proto === 'vless' && cfg.config_str.includes('reality')) return 'reality';
             return proto;
        }

        const categorized = {};
        configs.forEach(cfg => {
            const protocol = getProtocol(cfg);
            if (!categorized[protocol]) categorized[protocol] = [];
            categorized[protocol].push(cfg);
        });
        
        for (const protocol in categorized) {
            const protocolConfigs = categorized[protocol];
            if (protocolConfigs.length > 0) {
                const item = document.createElement('div');
                item.className = 'protocol-accordion-item';
                item.innerHTML = `
                    <div class="protocol-accordion-header">
                        <h3>${protocol.toUpperCase()} (${protocolConfigs.length})</h3>
                        <button class="link-btn copy-protocol-btn">Ú©Ù¾ÛŒ Ù‡Ù…Ù‡</button>
                    </div>
                    <div class="protocol-accordion-content"><div class="config-grid"></div></div>`;
                
                const content = item.querySelector('.protocol-accordion-content');
                const grid = item.querySelector('.config-grid');
                protocolConfigs.forEach(cfg => grid.appendChild(createConfigCard(cfg)));

                item.querySelector('.protocol-accordion-header').onclick = (e) => {
                    if (e.target.classList.contains('copy-protocol-btn')) return;
                    content.style.display = content.style.display === 'block' ? 'none' : 'block';
                };
                item.querySelector('.copy-protocol-btn').onclick = (e) => {
                    const text = protocolConfigs.map(c => c.config_str).join('\n');
                    copyToClipboard(text, e.target);
                };
                container.appendChild(item);
            }
        }
    };
    
    const renderCoreContent = (coreName, configs, container) => {
        const coreTitle = coreName.charAt(0).toUpperCase() + coreName.slice(1);
        container.innerHTML = `
            <button class="speed-test-btn" id="test-${coreName}">ğŸš€ ØªØ³Øª Ø³Ø±Ø¹Øª Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ÛŒ ${coreTitle}</button>
            <div class="links-container">
                <h3>Ù„ÛŒÙ†Ú©â€ŒÙ‡Ø§ÛŒ Ø§Ø´ØªØ±Ø§Ú© Ùˆ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ (Ø¨Ø¹Ø¯ Ø§Ø² ØªØ³Øª)</h3>
                <div class="link-group">
                    <h4>Ù„ÛŒÙ†Ú© Ø§Ø´ØªØ±Ø§Ú© (Subscription)</h4>
                    <div class="link-buttons">
                        <button class="link-btn copy-sub-btn">Ú©Ù¾ÛŒ Ù„ÛŒÙ†Ú© Base64</button>
                        <button class="link-btn qr-sub-btn">QR Ú©Ø¯ Ù„ÛŒÙ†Ú©</button>
                    </div>
                </div>
                <div class="link-group">
                    <h4>ÙØ§ÛŒÙ„ Ú©Ù„Ø´ (Clash Meta)</h4>
                    <div class="link-buttons">
                         <button class="link-btn download-clash-btn">Ø¯Ø§Ù†Ù„ÙˆØ¯ ÙØ§ÛŒÙ„ YAML</button>
                    </div>
                </div>
            </div>
            <div class="protocol-container"></div>`;

        container.querySelector(`#test-${coreName}`).onclick = (e) => startClientSideBatchTest(coreName, e.target);
        
        container.querySelector('.copy-sub-btn').onclick = (e) => {
            if (!testCompleted[coreName]) { alert('Ù„Ø·ÙØ§Ù‹ Ø§Ø¨ØªØ¯Ø§ ØªØ³Øª Ø³Ø±Ø¹Øª Ø±Ø§ Ø§Ù†Ø¬Ø§Ù… Ø¯Ù‡ÛŒØ¯.'); return; }
            const subContent = generateSubscriptionContent(allConfigs[coreName]);
            if (!subContent) { alert('Ù‡ÛŒÚ† Ú©Ø§Ù†ÙÛŒÚ¯ Ø³Ø§Ù„Ù…ÛŒ Ø¨Ø±Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯ Ù„ÛŒÙ†Ú© ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.'); return; }
            copyToClipboard(subContent, e.target);
        };
        
        container.querySelector('.qr-sub-btn').onclick = (e) => {
            if (!testCompleted[coreName]) { alert('Ù„Ø·ÙØ§Ù‹ Ø§Ø¨ØªØ¯Ø§ ØªØ³Øª Ø³Ø±Ø¹Øª Ø±Ø§ Ø§Ù†Ø¬Ø§Ù… Ø¯Ù‡ÛŒØ¯.'); return; }
            const subContent = generateSubscriptionContent(allConfigs[coreName]);
            if (!subContent) { alert('Ù‡ÛŒÚ† Ú©Ø§Ù†ÙÛŒÚ¯ Ø³Ø§Ù„Ù…ÛŒ Ø¨Ø±Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯ Ù„ÛŒÙ†Ú© ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.'); return; }
            // QR codes for subscriptions are tricky. This creates a link to a service that can serve the content.
            // A better approach would be to host the subscription file. For now, this is a placeholder.
            alert('Ø³Ø§Ø®Øª QR Ú©Ø¯ Ø¨Ø±Ø§ÛŒ Ù„ÛŒÙ†Ú© Ø§Ø´ØªØ±Ø§Ú© Ù†ÛŒØ§Ø²Ù…Ù†Ø¯ Ù…ÛŒØ²Ø¨Ø§Ù†ÛŒ ÙØ§ÛŒÙ„ Ø§Ø³Øª. Ø§ÛŒÙ† Ù‚Ø§Ø¨Ù„ÛŒØª Ø¯Ø± Ø¢ÛŒÙ†Ø¯Ù‡ Ø§Ø¶Ø§ÙÙ‡ Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯.');
        };
        
        container.querySelector('.download-clash-btn').onclick = () => {
            if (!testCompleted[coreName]) { alert('Ù„Ø·ÙØ§Ù‹ Ø§Ø¨ØªØ¯Ø§ ØªØ³Øª Ø³Ø±Ø¹Øª Ø±Ø§ Ø§Ù†Ø¬Ø§Ù… Ø¯Ù‡ÛŒØ¯.'); return; }
            const yamlContent = generateClashYaml(allConfigs[coreName]);
            if (!yamlContent) { alert('Ù‡ÛŒÚ† Ú©Ø§Ù†ÙÛŒÚ¯ Ø³Ø§Ù„Ù…ÛŒ Ø¨Ø±Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯ ÙØ§ÛŒÙ„ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.'); return; }
            const blob = new Blob([yamlContent], { type: 'text/yaml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `v2v_${coreName}_clash.yaml`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        renderProtocolAccordions(configs, container.querySelector('.protocol-container'));
    };

    const initializeApp = async () => {
        let rawJsonData;
        try {
            const response = await fetch(CONFIG_SOURCES[0], { cache: "no-store" });
            if (!response.ok) throw new Error('Primary source failed');
            rawJsonData = await response.json();
        } catch (error) {
            try {
                const response = await fetch(CONFIG_SOURCES[1], { cache: "no-store" });
                if (!response.ok) throw new Error('Backup source failed');
                rawJsonData = await response.json();
            } catch (backupError) {
                infoContainer.textContent = 'âš ï¸ ØªÙ…Ø§Ù… Ù…Ù†Ø§Ø¨Ø¹ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³ØªÙ†Ø¯. Ù„Ø·ÙØ§Ù‹ Ø¨Ø¹Ø¯Ø§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯.';
                return;
            }
        }

        if (!rawJsonData || (!rawJsonData.xray && !rawJsonData.singbox)) {
            infoContainer.textContent = 'âš ï¸ ÙØ§ÛŒÙ„ Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ Ø®Ø§Ù„ÛŒ Ø§Ø³Øª ÛŒØ§ Ø³Ø§Ø®ØªØ§Ø± Ø¯Ø±Ø³ØªÛŒ Ù†Ø¯Ø§Ø±Ø¯.'; return;
        }
        
        let idCounter = 0;
        allConfigs.xray = (rawJsonData.xray || []).map(cfg => ({id: idCounter++, config_str: cfg, name: extractNameFromUrl(cfg), core: 'xray', ping: null}));
        allConfigs.singbox = (rawJsonData.singbox || []).map(cfg => ({id: idCounter++, config_str: cfg, name: extractNameFromUrl(cfg), core: 'singbox', ping: null}));
        
        const totalCount = allConfigs.xray.length + allConfigs.singbox.length;
        infoContainer.textContent = `Ù…Ø¬Ù…ÙˆØ¹ ${totalCount} Ú©Ø§Ù†ÙÛŒÚ¯ (Xray: ${allConfigs.xray.length}, Sing-box: ${allConfigs.singbox.length}) Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯.`;

        if (allConfigs.xray.length > 0) {
            xrayBtn.style.display = 'block';
            renderCoreContent('xray', allConfigs.xray, xrayContent);
        }
        if (allConfigs.singbox.length > 0) {
            singboxBtn.style.display = 'block';
            renderCoreContent('singbox', allConfigs.singbox, singboxContent);
        }
    };

    xrayBtn.onclick = () => { xrayContent.style.display = xrayContent.style.display === 'block' ? 'none' : 'block'; };
    singboxBtn.onclick = () => { singboxContent.style.display = singboxContent.style.display === 'block' ? 'none' : 'block'; };
    closeBtn.onclick = () => qrModal.style.display = "none";
    window.onclick = (event) => { if (event.target == qrModal) qrModal.style.display = "none"; };
    
    initializeApp();
});
</script>
</body>
</html>
