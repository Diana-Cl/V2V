// index.js (Final Version - Configs from Static, Ping/Sub from Workers)

document.addEventListener('DOMContentLoaded', () => {
    // --- Configuration ---
    const WORKER_URLS = [
        'https://rapid-scene-1da6.mbrgh87.workers.dev',
        'https://v2v-proxy.mbrgh87.workers.dev',
        'https://v2v.mbrgh87.workers.dev',
        'https://winter-hill-0307.mbrgh87.workers.dev',
    ];
    
    // IMPORTANT: These URLs MUST point to the 'output/all_live_configs.json' file
    // that is generated by the scraper and committed to your repository,
    // then hosted by your static providers.
    const FALLBACK_STATIC_URLS = [
        'https://smbcryp.github.io/v2v-data/output/all_live_configs.json', // GitHub Pages
        'https://v2v-vercel.vercel.app/output/all_live_configs.json', // Vercel - assuming it exposes files from output/
        'https://v2v-data.pages.dev/output/all_live_configs.json', // Cloudflare Pages - if you are using this
        'https://s3.ir-thr-at1.arvanstorage.com/v2v-data/output/all_live_configs.json', // ArvanCloud S3
    ];

    const PING_TIMEOUT = 5000;
    
    // --- DOM Elements ---
    const getEl = (id) => document.getElementById(id);
    const statusBar = getEl('status-bar');
    const xrayWrapper = getEl('xray-content-wrapper');
    const singboxWrapper = getEl('singbox-content-wrapper');
    const qrModal = getEl('qr-modal');
    const qrContainer = getEl('qr-code-container');
    const toastEl = getEl('toast');
    let userUuid = localStorage.getItem('v2v_user_uuid') || null;

    // --- Helper Functions ---
    const showToast = (message, isError = false) => {
        toastEl.textContent = message;
        toastEl.className = `toast show ${isError ? 'error' : ''}`;
        setTimeout(() => toastEl.classList.remove('show'), 3000);
    };

    const copyToClipboard = async (text, successMessage = 'Ú©Ù¾ÛŒ Ø´Ø¯!') => {
        try {
            await navigator.clipboard.writeText(text);
            showToast(successMessage);
        } catch (err) { showToast('Ø®Ø·Ø§ Ø¯Ø± Ú©Ù¾ÛŒ Ú©Ø±Ø¯Ù†!', true); }
    };

    const openQrModal = (text) => {
        if (!window.QRCode) { 
            showToast('Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ QR Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø§Ø³Øª... Ù„Ø·ÙØ§ ØµØ¨Ø± Ú©Ù†ÛŒØ¯ ÛŒØ§ ØµÙØ­Ù‡ Ø±Ø§ Ø±ÙØ±Ø´ Ú©Ù†ÛŒØ¯.', true); 
            console.error("QR Code library not loaded.");
            return; 
        }
        qrContainer.innerHTML = '';
        new QRCode(qrContainer, { text, width: 256, height: 256, correctLevel: QRCode.CorrectLevel.H });
        qrModal.style.display = 'flex';
    };

    // --- Core Logic ---
    const fetchWithFailover = async (urls) => {
        for (const url of urls) {
            try {
                const fetchUrl = new URL(url);
                // No need for ?v=Date.now() on static files, as GH Pages/Vercel handles caching better
                // Also, Cloudflare CDN for GitHub Pages might cache well.
                const response = await fetch(fetchUrl.toString(), { signal: AbortSignal.timeout(8000) });
                if (!response.ok) throw new Error(`Status ${response.status}`);
                console.log(`Successfully fetched from: ${url}`);
                return response;
            } catch (error) {
                console.warn(`Failed to fetch from ${url}:`, error.message);
            }
        }
        throw new Error('ØªÙ…Ø§Ù… Ù…Ù†Ø§Ø¨Ø¹ Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ù†ÙÛŒÚ¯ Ø§Ø² Ø¯Ø³ØªØ±Ø³ Ø®Ø§Ø±Ø¬ Ù‡Ø³ØªÙ†Ø¯.');
    };
    
    let allLiveConfigsData = null;

    const fetchAndRender = async () => {
        statusBar.textContent = 'Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§...';
        try {
            // ONLY fetch from static URLs for configs
            const configResponse = await fetchWithFailover(FALLBACK_STATIC_URLS);
            allLiveConfigsData = await configResponse.json();
            
            let cacheVersion = 'Ù†Ø§Ù…Ø´Ø®Øµ'; // Default if not found
            // Attempt to fetch cache_version.txt from one of the static hosts
            for (const url of FALLBACK_STATIC_URLS) {
                try {
                    const versionUrl = url.replace('all_live_configs.json', 'cache_version.txt');
                    const versionResponse = await fetch(versionUrl, { signal: AbortSignal.timeout(3000) });
                    if (versionResponse.ok) {
                        cacheVersion = await versionResponse.text();
                        break; // Found it, no need to check other URLs
                    }
                } catch (error) {
                    console.warn(`Failed to fetch cache_version.txt from ${url.replace('all_live_configs.json', 'cache_version.txt')}:`, error.message);
                }
            }

            statusBar.textContent = `Ø¢Ø®Ø±ÛŒÙ† Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ: ${new Date(parseInt(cacheVersion) * 1000).toLocaleString('fa-IR', { dateStyle: 'short', timeStyle: 'short' })}`;
            renderCore('xray', allLiveConfigsData.xray, xrayWrapper);
            renderCore('singbox', allLiveConfigsData.singbox, singboxWrapper);
        } catch (error) {
            statusBar.textContent = 'Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§.';
            showToast(error.message, true);
            xrayWrapper.innerHTML = singboxWrapper.innerHTML = `<div class="alert">${error.message}</div>`;
        }
    };

    const renderCore = (coreName, coreData, wrapper) => {
        if (!coreData || Object.keys(coreData).length === 0) {
            wrapper.innerHTML = `<div class="alert">Ù‡ÛŒÚ† Ú©Ø§Ù†ÙÛŒÚ¯ÛŒ Ø¨Ø±Ø§ÛŒ Ù‡Ø³ØªÙ‡ ${coreName} ÛŒØ§ÙØª Ù†Ø´Ø¯.</div>`; return;
        }
        let html = `<button class="test-button" id="test-button-${coreName}" onclick="window.runPingTest('${coreName}')"><span class="test-button-text">ğŸš€ ØªØ³Øª Ù¾ÛŒÙ†Ú¯ Ù‡Ù…Ù‡ Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§</span></button>
            <div class="action-group-title">Ø³Ø§Ø®Øª Ø§Ø´ØªØ±Ø§Ú© Ø´Ø®ØµÛŒ</div>
            <div class="action-box"><span class="action-box-label">Ù„ÛŒÙ†Ú© Ø§Ø´ØªØ±Ø§Ú© / Sub-link</span><div class="action-box-buttons"><button class="action-btn-small" onclick="window.createPersonalSubscription('${coreName}', 'raw', 'copy')">Ú©Ù¾ÛŒ URL</button><button class="action-btn-small" onclick="window.createPersonalSubscription('${coreName}', 'raw', 'qr')">QR Code</button></div></div>
            <div class="action-box"><span class="action-box-label">Ù„ÛŒÙ†Ú© Clash</span><div class="action-box-buttons"><button class="action-btn-small" onclick="window.createPersonalSubscription('${coreName}', 'clash', 'copy')">Ú©Ù¾ÛŒ URL</button><button class="action-btn-small" onclick="window.createPersonalSubscription('${coreName}', 'clash', 'qr')">QR Code</button></div></div>
            <div class="action-box"><span class="action-box-label">Ù„ÛŒÙ†Ú© Sing-box</span><div class="action-box-buttons"><button class="action-btn-small" onclick="window.createPersonalSubscription('${coreName}', 'singbox', 'copy')">Ú©Ù¾ÛŒ URL</button><button class="action-btn-small" onclick="window.createPersonalSubscription('${coreName}', 'singbox', 'qr')">QR Code</button></div></div>`;
        
        for (const protocol in coreData) {
            html += `<div class="protocol-group open" id="${coreName}-${protocol}-group">
                <div class="protocol-header" onclick="this.parentElement.classList.toggle('open')"><span>${protocol.toUpperCase()} (${coreData[protocol].length})</span><span class="toggle-icon">â–¼</span></div>
                <ul class="config-list">
                    ${coreData[protocol].map(config => {
                        const safeConfig = config.replace(/'/g, "&apos;").replace(/"/g, '&quot;');
                        let name = 'v2v-config'; 
                        try { 
                            const url = new URL(config);
                            name = decodeURIComponent(url.hash.substring(1) || url.hostname); 
                        } catch (e) {
                             // Handle vmess:// config special case for name extraction
                             if (config.startsWith('vmess://')) {
                                try {
                                    const data = JSON.parse(atob(config.substring(8)));
                                    name = data.ps || data.add;
                                } catch (parseError) { /* ignore */ }
                             }
                        }
                        return `<li class="config-item" data-config='${safeConfig}' id="config-item-${btoa(config).replace(/=/g, '')}"><input type="checkbox" class="config-checkbox"><div class="config-details"><span class="server">${name}</span></div><div class="ping-result-container"></div><button class="copy-btn" onclick="copyToClipboard('${safeConfig}')">Ú©Ù¾ÛŒ</button><button class="copy-btn" onclick="openQrModal('${safeConfig}')">QR</button></li>`;
                    }).join('')}
                </ul></div>`;
        }
        wrapper.innerHTML = html;
    };

    const parseConfigForPing = (configUrl) => {
        try {
            if (configUrl.startsWith('vmess://')) {
                const data = JSON.parse(atob(configUrl.substring(8)));
                return { host: data.add, port: parseInt(data.port), tls: data.tls === 'tls', sni: data.sni || data.host };
            }
            const url = new URL(configUrl);
            const params = new URLSearchParams(url.search);
            const scheme = url.protocol.replace(':', '');
            // More robust TLS detection for ping
            const tls = (params.get('security') === 'tls' || scheme === 'trojan' || ['hy2', 'hysteria2', 'tuic'].includes(scheme) || (params.get('tls') === '1' || params.get('fp')));
            const sni = params.get('sni') || url.hostname;
            return { host: url.hostname, port: parseInt(url.port), tls, sni };
        } catch { return null; }
    };
    
    window.runPingTest = async (coreName) => {
        const testButton = getEl(`test-button-${coreName}`);
        if (testButton.disabled) return;
        testButton.disabled = true;
        testButton.querySelector('.test-button-text').textContent = 'Ø¯Ø± Ø­Ø§Ù„ ØªØ³Øª Ù¾ÛŒÙ†Ú¯...';

        const allItems = Array.from(document.querySelectorAll(`#${coreName}-section .config-item`));
        allItems.forEach(item => item.dataset.latency = Infinity); // Reset latency
        
        let workerIndex = 0;
        const pingPromises = allItems.map(item => (async () => {
            const resultContainer = item.querySelector('.ping-result-container');
            resultContainer.innerHTML = `<span class="loader-small"></span>`;
            
            const configData = parseConfigForPing(item.dataset.config);
            if (!configData) {
                resultContainer.innerHTML = `<strong style="color:var(--ping-bad);">âŒ</strong>`; return;
            }
            
            const currentWorkerUrl = WORKER_URLS[workerIndex++ % WORKER_URLS.length];
            try {
                const response = await fetch(`${currentWorkerUrl}/ping`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(configData), signal: AbortSignal.timeout(PING_TIMEOUT)
                });
                const result = await response.json();
                if (result.status === 'Live') {
                    item.dataset.latency = result.latency;
                    resultContainer.innerHTML = `<strong style="color:${result.latency < 500 ? 'var(--ping-good)' : (result.latency < 1500 ? 'var(--ping-medium)' : 'var(--ping-bad)')};">${result.latency}ms</strong>`;
                } else {
                    resultContainer.innerHTML = `<strong style="color:var(--ping-bad);">âŒ</strong>`;
                }
            } catch (e) {
                resultContainer.innerHTML = `<strong style="color:var(--ping-bad);">âŒ</strong>`;
            }
        })());

        let completed = 0;
        // Use Promise.allSettled to wait for all pings to finish, regardless of success/failure
        Promise.allSettled(pingPromises).then(() => {
            const protocolGroups = document.querySelectorAll(`#${coreName}-section .protocol-group`);
            protocolGroups.forEach(group => {
                const configsInGroup = Array.from(group.querySelectorAll('.config-item'));
                configsInGroup.sort((a, b) => a.dataset.latency - b.dataset.latency);
                configsInGroup.forEach(li => group.querySelector('.config-list').appendChild(li));
            });
            testButton.querySelector('.test-button-text').textContent = 'ğŸš€ ØªØ³Øª Ù…Ø¬Ø¯Ø¯ Ù¾ÛŒÙ†Ú¯';
            testButton.disabled = false;
            showToast('ØªØ³Øª Ù¾ÛŒÙ†Ú¯ Ú©Ø§Ù…Ù„ Ø´Ø¯.');
        });
    };

    window.createPersonalSubscription = async (coreName, format, method = 'copy') => {
        const selectedConfigs = Array.from(document.querySelectorAll(`#${coreName}-section .config-checkbox:checked`)).map(cb => cb.closest('.config-item').dataset.config);
        if (selectedConfigs.length === 0) { showToast('Ù„Ø·ÙØ§ Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© Ú©Ø§Ù†ÙÛŒÚ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯!', true); return; }
        showToast('Ø¯Ø± Ø­Ø§Ù„ Ø³Ø§Ø®Øª Ù„ÛŒÙ†Ú© Ø§Ø´ØªØ±Ø§Ú©...', false);
        const activeWorkerUrl = WORKER_URLS[Math.floor(Math.random() * WORKER_URLS.length)];
        try {
            const response = await fetch(`${activeWorkerUrl}/create-personal-sub`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ configs: selectedConfigs, uuid: userUuid }),
            });
            const data = await response.json();
            if (!response.ok) throw new Error(data.error || 'Ø®Ø·Ø§ÛŒ Ù†Ø§Ø´Ù†Ø§Ø®ØªÙ‡');
            userUuid = data.uuid;
            localStorage.setItem('v2v_user_uuid', userUuid);
            const urlToUse = format === 'clash' ? data.clashSubscriptionUrl : (format === 'singbox' ? data.singboxSubscriptionUrl : data.subscriptionUrl);
            
            // Refined method handling
            if (method === 'copy') {
                 await copyToClipboard(urlToUse, 'Ù„ÛŒÙ†Ú© Ø§Ø´ØªØ±Ø§Ú© Ú©Ù¾ÛŒ Ø´Ø¯!');
            } else if (method === 'qr') {
                 openQrModal(urlToUse);
            } else { // Fallback for any other method, or if you had 'download' which is now primarily 'copy' or 'qr'
                // For direct download, typically you'd just open the URL.
                // Since this worker generates content-disposition, opening in new tab will trigger download.
                window.open(urlToUse, '_blank');
            }
        } catch (error) { showToast(`Ø®Ø·Ø§: ${error.message}`, true); }
    };

    fetchAndRender();
    qrModal.addEventListener('click', () => (qrModal.style.display = 'none'));
    document.addEventListener('keydown', (e) => e.key === 'Escape' && (qrModal.style.display = 'none'));
});
