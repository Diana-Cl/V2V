document.addEventListener('DOMContentLoaded', () => {
    const STATIC_CONFIG_URL = './all_live_configs.json?t=' + Date.now();
    const STATIC_CACHE_VERSION_URL = './cache_version.txt?t=' + Date.now();
    const WORKER_URLS = ['https://v2v-proxy.mbrgh87.workers.dev','https://v2v.mbrgh87.workers.dev','https://rapid-scene-1da6.mbrgh87.workers.dev','https://winter-hill-0307.mbrgh87.workers.dev'];
    const getEl = (id) => document.getElementById(id);
    const statusBar = getEl('status-bar');
    const xrayWrapper = getEl('xray-content-wrapper');
    const singboxWrapper = getEl('singbox-content-wrapper');
    const qrModal = getEl('qr-modal');
    const qrContainer = getEl('qr-code-container');
    const toastEl = getEl('toast');
    const showToast = (message, isError = false) => { toastEl.textContent = message; toastEl.className = `toast show ${isError ? 'error' : ''}`; setTimeout(() => toastEl.classList.remove('show'), 3000); };
    window.copyToClipboard = async (text, successMessage = 'Ú©Ù¾ÛŒ Ø´Ø¯!') => { try { await navigator.clipboard.writeText(text); showToast(successMessage); } catch (err) { showToast('Ø®Ø·Ø§ Ø¯Ø± Ú©Ù¾ÛŒ Ú©Ø±Ø¯Ù†!', true); } };
    window.openQrModal = (text) => { if (!window.QRCode) { showToast('Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ QR Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø§Ø³Øª...', true); return; } qrContainer.innerHTML = ''; new QRCode(qrContainer, { text, width: 256, height: 256, correctLevel: QRCode.CorrectLevel.H }); qrModal.style.display = 'flex'; };
    qrModal.addEventListener('click', (e) => { if (e.target === qrModal) { qrModal.style.display = 'none'; } });
    let allLiveConfigsData = null;
    let realPingResults = {};
    const getConfigHash = (config) => { try { const url = new URL(config); return `${url.protocol}//${url.hostname}:${url.port}:${url.username}`; } catch { return config; } };
    const removeDuplicates = (configs) => { const seen = new Set(); return configs.filter(config => { const hash = getConfigHash(config); if (seen.has(hash)) return false; seen.add(hash); return true; }); };
    const shortenName = (name, protocol, server) => { if (!name || name.length > 25) { return `${protocol}-${server.substring(0, 12)}`; } return name; };
    window.copyProtocolConfigs = (coreName, protocol) => { const coreData = allLiveConfigsData[coreName]; if (!coreData || !coreData[protocol] || coreData[protocol].length === 0) { showToast('Ú©Ø§Ù†ÙÛŒÚ¯ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯!', true); return; } const configs = coreData[protocol].join('\n'); window.copyToClipboard(configs, `${coreData[protocol].length} Ú©Ø§Ù†ÙÛŒÚ¯ ${protocol.toUpperCase()} Ú©Ù¾ÛŒ Ø´Ø¯!`); };
    window.selectAllProtocol = (coreName, protocol) => { const checkboxes = document.querySelectorAll(`input.config-checkbox[data-core="${coreName}"][data-protocol="${protocol}"]`); const allChecked = Array.from(checkboxes).every(cb => cb.checked); checkboxes.forEach(cb => { cb.checked = !allChecked; }); showToast(allChecked ? 'Ø§Ù†ØªØ®Ø§Ø¨ Ù‡Ù…Ù‡ Ù„ØºÙˆ Ø´Ø¯' : 'Ù‡Ù…Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù†Ø¯'); };
    window.generateSubscription = async (coreName, scope, format, action) => { let configs = []; if (scope === 'selected') { const checkboxes = document.querySelectorAll(`input.config-checkbox[data-core="${coreName}"]:checked`); if (checkboxes.length === 0) { showToast('Ù‡ÛŒÚ† Ú©Ø§Ù†ÙÛŒÚ¯ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡!', true); return; } configs = Array.from(checkboxes).map(cb => decodeURIComponent(cb.dataset.config)); } else if (scope === 'auto') { configs = getTopConfigsFromBackend(coreName); if (configs.length === 0) { showToast('Ú©Ø§Ù†ÙÛŒÚ¯ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯!', true); return; } } configs = removeDuplicates(configs); if (configs.length === 0) { showToast('Ú©Ø§Ù†ÙÛŒÚ¯ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯!', true); return; } showToast(`Ø¯Ø± Ø­Ø§Ù„ Ø³Ø§Ø®Øª ${format}...`); const createPromises = WORKER_URLS.map(async (workerUrl, index) => { try { const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), 15000); const response = await fetch(`${workerUrl}/create-sub`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ configs, format }), signal: controller.signal }); clearTimeout(timeoutId); if (response.ok) { const data = await response.json(); if (data.url) { return { success: true, url: data.url, workerIndex: index + 1 }; } } } catch (error) { console.error(`Worker ${index + 1} failed:`, error); } return { success: false }; }); try { const firstSuccess = await Promise.race(createPromises.map(p => p.then(result => result.success ? result : Promise.reject(result)))).catch(() => null); if (firstSuccess) { if (action === 'copy') { await window.copyToClipboard(firstSuccess.url, `âœ… Ù„ÛŒÙ†Ú© ${format} Ú©Ù¾ÛŒ Ø´Ø¯! (Worker ${firstSuccess.workerIndex})`); } else if (action === 'qr') { window.openQrModal(firstSuccess.url); showToast(`âœ… QR ${format} Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯!`); } return; } const allResults = await Promise.all(createPromises); const successResult = allResults.find(r => r.success); if (successResult) { if (action === 'copy') { await window.copyToClipboard(successResult.url, `âœ… Ù„ÛŒÙ†Ú© ${format} Ú©Ù¾ÛŒ Ø´Ø¯!`); } else if (action === 'qr') { window.openQrModal(successResult.url); showToast(`âœ… QR ${format} Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯!`); } return; } throw new Error('All workers failed'); } catch (error) { console.error('Subscription creation failed:', error); showToast(`âŒ Ø®Ø·Ø§ Ø¯Ø± Ø³Ø§Ø®Øª ${format}!`, true); } };
    const getTopConfigsFromBackend = (coreName) => { const coreData = allLiveConfigsData[coreName]; const allConfigs = []; for (const protocol in coreData) { coreData[protocol].forEach((config, idx) => { const key = `${coreName}-${protocol}-${idx}`; const ping = realPingResults[key]; if (ping && ping > 0 && ping < 500) { allConfigs.push({ config, ping }); } }); } if (allConfigs.length === 0) { for (const protocol in coreData) { allConfigs.push(...coreData[protocol].slice(0, 5).map(config => ({ config, ping: 9999 }))); } } allConfigs.sort((a, b) => a.ping - b.ping); return removeDuplicates(allConfigs.slice(0, 20).map(item => item.config)); };
    const fetchAndRender = async () => { console.log('ğŸš€ Starting V2V Client...'); statusBar.textContent = 'Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ...'; try { console.log('ğŸ“¥ Fetching configs from:', STATIC_CONFIG_URL); const configResponse = await fetch(STATIC_CONFIG_URL, { cache: 'no-store', headers: { 'Accept': 'application/json' } }); if (!configResponse.ok) { throw new Error(`HTTP ${configResponse.status}: ${configResponse.statusText}`); } const responseText = await configResponse.text(); console.log('ğŸ“¦ Response length:', responseText.length); allLiveConfigsData = JSON.parse(responseText); console.log('âœ… Parsed JSON successfully'); if (!allLiveConfigsData.xray || !allLiveConfigsData.singbox) { throw new Error('Invalid data structure'); } for (const core in allLiveConfigsData) { for (const protocol in allLiveConfigsData[core]) { const before = allLiveConfigsData[core][protocol].length; allLiveConfigsData[core][protocol] = removeDuplicates(allLiveConfigsData[core][protocol]); const after = allLiveConfigsData[core][protocol].length; if (before !== after) { console.log(`ğŸ§¹ Removed ${before - after} duplicates from ${core}/${protocol}`); } } } let cacheVersion = 'Ù†Ø§Ù…Ø´Ø®Øµ'; try { const versionResponse = await fetch(STATIC_CACHE_VERSION_URL, { cache: 'no-store' }); if (versionResponse.ok) { cacheVersion = await versionResponse.text(); } } catch (e) { console.warn('Cache version fetch failed:', e); } const updateTime = new Date(parseInt(cacheVersion) * 1000).toLocaleString('fa-IR', { dateStyle: 'short', timeStyle: 'short' }); statusBar.textContent = `Ø¢Ø®Ø±ÛŒÙ† Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ: ${updateTime}`; console.log('ğŸ¨ Rendering cores...'); renderCore('xray', allLiveConfigsData.xray, xrayWrapper); renderCore('singbox', allLiveConfigsData.singbox, singboxWrapper); const xrayTotal = Object.values(allLiveConfigsData.xray).reduce((sum, arr) => sum + arr.length, 0); const singboxTotal = Object.values(allLiveConfigsData.singbox).reduce((sum, arr) => sum + arr.length, 0); console.log(`ğŸ“Š Stats: Xray=${xrayTotal}, Singbox=${singboxTotal}, Total=${xrayTotal + singboxTotal}`); console.log('âœ… V2V loaded successfully!'); } catch (error) { console.error('âŒ Fatal error:', error); statusBar.textContent = 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ'; xrayWrapper.innerHTML = `<div class="alert">âŒ Ø®Ø·Ø§: ${error.message}<br><small>Ù„Ø·ÙØ§Ù‹ ØµÙØ­Ù‡ Ø±Ø§ Ø±ÙØ±Ø´ Ú©Ù†ÛŒØ¯</small></div>`; singboxWrapper.innerHTML = `<div class="alert">âŒ Ø®Ø·Ø§: ${error.message}<br><small>Ù„Ø·ÙØ§Ù‹ ØµÙØ­Ù‡ Ø±Ø§ Ø±ÙØ±Ø´ Ú©Ù†ÛŒØ¯</small></div>`; showToast('Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§!', true); } };
    const renderCore = (coreName, coreData, wrapper) => { if (!coreData || Object.keys(coreData).length === 0) { wrapper.innerHTML = `<div class="alert">Ú©Ø§Ù†ÙÛŒÚ¯ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯.</div>`; return; } const totalConfigs = Object.values(coreData).reduce((sum, arr) => sum + arr.length, 0); const realTestButton = `<button class="test-button" style="background: linear-gradient(135deg, #c31432, #240b36); margin-bottom: 15px;" onclick="window.startRealPingTest('${coreName}')" id="real-test-${coreName}-btn">ğŸŒ ØªØ³Øª ÙˆØ§Ù‚Ø¹ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ø§Ø² Ø´Ø¨Ú©Ù‡ Ø´Ù…Ø§ (${totalConfigs} Ú©Ø§Ù†ÙÛŒÚ¯)</button>`; const copySelectedButton = `<button class="action-btn-wide" onclick="window.copySelectedConfigs('${coreName}')">ğŸ“‹ Ú©Ù¾ÛŒ Ù…ÙˆØ§Ø±Ø¯ Ø§Ù†ØªØ®Ø§Ø¨ÛŒ</button>`; let contentHtml = `<div class="action-bar">${realTestButton}${copySelectedButton}</div>`; if (coreName === 'xray') { contentHtml += `<div class="sub-section"><div class="sub-title">ğŸ”· Xray Subscription (Ø®Ø§Ù…)</div><div class="sub-actions"><button class="sub-btn" onclick="window.generateSubscription('${coreName}', 'selected', 'xray', 'copy')">Ø§Ù†ØªØ®Ø§Ø¨ÛŒ</button><button class="sub-btn primary" onclick="window.generateSubscription('${coreName}', 'auto', 'xray', 'copy')">Ø®ÙˆØ¯Ú©Ø§Ø± (Ø¨Ù‡ØªØ±ÛŒÙ†â€ŒÙ‡Ø§)</button><button class="sub-btn qr" onclick="window.generateSubscription('${coreName}', 'auto', 'xray', 'qr')">ğŸ“± QR</button></div></div><div class="sub-section"><div class="sub-title">âš¡ Clash for Xray</div><div class="sub-actions"><button class="sub-btn" onclick="window.generateSubscription('${coreName}', 'selected', 'xray-clash', 'copy')">Ø§Ù†ØªØ®Ø§Ø¨ÛŒ</button><button class="sub-btn primary" onclick="window.generateSubscription('${coreName}', 'auto', 'xray-clash', 'copy')">Ø®ÙˆØ¯Ú©Ø§Ø± (Ø¨Ù‡ØªØ±ÛŒÙ†â€ŒÙ‡Ø§)</button><button class="sub-btn qr" onclick="window.generateSubscription('${coreName}', 'auto', 'xray-clash', 'qr')">ğŸ“± QR</button></div></div>`; } else if (coreName === 'singbox') { contentHtml += `<div class="sub-section"><div class="sub-title">ğŸ“¦ Singbox Subscription</div><div class="sub-actions"><button class="sub-btn" onclick="window.generateSubscription('${coreName}', 'selected', 'singbox', 'copy')">Ø§Ù†ØªØ®Ø§Ø¨ÛŒ</button><button class="sub-btn primary" onclick="window.generateSubscription('${coreName}', 'auto', 'singbox', 'copy')">Ø®ÙˆØ¯Ú©Ø§Ø± (Ø¨Ù‡ØªØ±ÛŒÙ†â€ŒÙ‡Ø§)</button><button class="sub-btn qr" onclick="window.generateSubscription('${coreName}', 'auto', 'singbox', 'qr')">ğŸ“± QR</button></div></div><div class="sub-section"><div class="sub-title">âš¡ Clash for Singbox</div><div class="sub-actions"><button class="sub-btn" onclick="window.generateSubscription('${coreName}', 'selected', 'singbox-clash', 'copy')">Ø§Ù†ØªØ®Ø§Ø¨ÛŒ</button><button class="sub-btn primary" onclick="window.generateSubscription('${coreName}', 'auto', 'singbox-clash', 'copy')">Ø®ÙˆØ¯Ú©Ø§Ø± (Ø¨Ù‡ØªØ±ÛŒÙ†â€ŒÙ‡Ø§)</button><button class="sub-btn qr" onclick="window.generateSubscription('${coreName}', 'auto', 'singbox-clash', 'qr')">ğŸ“± QR</button></div></div>`; } for (const protocol in coreData) { const configs = coreData[protocol]; if (configs.length === 0) continue; const protocolMap = {'vmess': 'VMess', 'vless': 'VLESS', 'trojan': 'Trojan', 'ss': 'Shadowsocks', 'hy2': 'Hysteria2', 'tuic': 'TUIC'}; const protocolName = protocolMap[protocol] || protocol.toUpperCase(); contentHtml += `<div class="protocol-group" data-protocol="${protocol}"><div class="protocol-header"><span class="protocol-name">${protocolName} <span class="badge">${configs.length}</span></span><div class="protocol-actions"><button class="btn-copy-protocol" onclick="window.selectAllProtocol('${coreName}', '${protocol}')" title="Ø§Ù†ØªØ®Ø§Ø¨ Ù‡Ù…Ù‡">â˜‘ï¸</button><button class="btn-copy-protocol" onclick="window.copyProtocolConfigs('${coreName}', '${protocol}')" title="Ú©Ù¾ÛŒ Ù‡Ù…Ù‡">ğŸ“‹</button><svg class="toggle-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"></polyline></svg></div></div><ul class="config-list">`; configs.forEach((config, idx) => { try { const urlObj = new URL(config); const server = urlObj.hostname; const port = urlObj.port; const rawName = decodeURIComponent(urlObj.hash.substring(1) || `${protocol}-${server}`); const name = shortenName(rawName, protocol, server); contentHtml += `<li class="config-item" data-config-key="${coreName}-${protocol}-${idx}"><input type="checkbox" class="config-checkbox" data-core="${coreName}" data-protocol="${protocol}" data-config="${encodeURIComponent(config)}" id="${coreName}-${protocol}-${idx}"><div class="config-info"><label for="${coreName}-${protocol}-${idx}" class="config-name">${name}</label><span class="server">${server}:${port}</span></div><span class="ping-result" id="ping-${coreName}-${protocol}-${idx}"></span><div class="config-btns"><button class="btn-icon" onclick="window.copyToClipboard(decodeURIComponent('${encodeURIComponent(config)}'))" title="Ú©Ù¾ÛŒ">ğŸ“‹</button><button class="btn-icon" onclick="window.openQrModal(decodeURIComponent('${encodeURIComponent(config)}'))" title="QR">ğŸ“±</button></div></li>`; } catch (e) { console.warn('Config parse error:', e); } }); contentHtml += `</ul></div>`; } wrapper.innerHTML = contentHtml; wrapper.querySelectorAll('.protocol-header').forEach(header => { header.addEventListener('click', (e) => { if (!e.target.classList.contains('btn-copy-protocol') && !e.target.closest('.btn-copy-protocol')) { header.closest('.protocol-group').classList.toggle('open'); } }); }); };
    window.copySelectedConfigs = (coreName) => { const checkboxes = document.querySelectorAll(`input.config-checkbox[data-core="${coreName}"]:checked`); if (checkboxes.length === 0) { showToast('Ù‡ÛŒÚ† Ú©Ø§Ù†ÙÛŒÚ¯ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡!', true); return; } const configs = Array.from(checkboxes).map(cb => decodeURIComponent(cb.dataset.config)); window.copyToClipboard(configs.join('\n'), `${configs.length} Ú©Ø§Ù†ÙÛŒÚ¯ Ú©Ù¾ÛŒ Ø´Ø¯!`); };
    async function tcpPingAdvanced(server, port, protocol, attempts = 3) { const latencies = []; let useHttps = false; const httpsProtocols = ['vless', 'vmess', 'trojan', 'tuic', 'hy2']; const httpsPorts = ['443', '8443', '2096', '2053', '2083', '2087', '2052', '2082', '8880']; if (httpsProtocols.includes(protocol) || httpsPorts.includes(port)) { useHttps = true; } const connectionProtocol = useHttps ? 'https' : 'http'; for (let i = 0; i < attempts; i++) { try { const start = performance.now(); await Promise.race([ new Promise((resolve, reject) => { const img = new Image(); const timeout = setTimeout(() => { img.src = ''; reject(new Error('timeout')); }, 4000); img.onload = img.onerror = () => { clearTimeout(timeout); resolve(); }; img.src = `${connectionProtocol}://${server}:${port}/favicon.ico?_=${Date.now()}_${i}`; }), (async () => { const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), 3500); try { await fetch(`${connectionProtocol}://${server}:${port}`, { method: 'HEAD', mode: 'no-cors', cache: 'no-store', signal: controller.signal }); } catch (e) {} finally { clearTimeout(timeoutId); } })() ]); const latency = Math.round(performance.now() - start); if (latency < 4000) { latencies.push(latency); } } catch {} if (i < attempts - 1) { await new Promise(r => setTimeout(r, 100)); } } if (latencies.length === 0) { return { status: 'Dead', latency: null, jitter: null }; } const avg = Math.round(latencies.reduce((a, b) => a + b) / latencies.length); const min = Math.min(...latencies); const max = Math.max(...latencies); const jitter = latencies.length > 1 ? Math.round(Math.sqrt(latencies.reduce((sum, lat) => sum + Math.pow(lat - avg, 2), 0) / latencies.length)) : 0; return { status: 'Live', latency: avg, min: min, max: max, jitter: jitter, stability: jitter < 20 ? 'excellent' : jitter < 50 ? 'good' : 'poor' }; }
    window.startRealPingTest = async (coreName) => { const btn = getEl(`real-test-${coreName}-btn`); if (!btn) return; const confirmTest = confirm(`ğŸŒ ØªØ³Øª ÙˆØ§Ù‚Ø¹ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ø§Ø² Ø´Ø¨Ú©Ù‡ Ø´Ù…Ø§\n\nâœ¨ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯:\nâ€¢ ØªØ³Øª 3 Ù…Ø±Ø­Ù„Ù‡â€ŒØ§ÛŒ (Image + Fetch)\nâ€¢ Ù…Ø­Ø§Ø³Ø¨Ù‡ Jitter (Ù¾Ø§ÛŒØ¯Ø§Ø±ÛŒ)\nâ€¢ Ù†Ù…Ø§ÛŒØ´ Min/Max/Avg\nâ€¢ ØªØ´Ø®ÛŒØµ Ø¨Ù‡ØªØ±ÛŒÙ† Ú©Ø§Ù†ÙÛŒÚ¯\n\nâœ… Ù‡Ù…Ù‡ Ù¾Ø±ÙˆØªÚ©Ù„â€ŒÙ‡Ø§: VMess, VLESS, Trojan, SS, Hy2, TUIC\nâš¡ Ø³Ø±Ø¹Øª: 50 Ú©Ø§Ù†ÙÛŒÚ¯ Ù‡Ù…Ø²Ù…Ø§Ù†\nâ±ï¸ Ø²Ù…Ø§Ù†: 2-4 Ø¯Ù‚ÛŒÙ‚Ù‡\n\nØ§Ø¯Ø§Ù…Ù‡ Ù…ÛŒØ¯ÛŒØŸ`); if (!confirmTest) return; btn.disabled = true; btn.innerHTML = `<span class="loader-small"></span> Ø¯Ø± Ø­Ø§Ù„ ØªØ³Øª Ù¾ÛŒØ´Ø±ÙØªÙ‡...`; realPingResults = {}; const coreData = allLiveConfigsData[coreName]; const allConfigs = []; for (const protocol in coreData) { coreData[protocol].forEach((config, idx) => { try { const urlObj = new URL(config); allConfigs.push({ config, protocol, idx, server: urlObj.hostname, port: urlObj.port || '443' }); } catch {} }); } let completed = 0; const total = allConfigs.length; let liveCount = 0; let deadCount = 0; let excellentCount = 0; showToast(`Ø´Ø±ÙˆØ¹ ØªØ³Øª Ù¾ÛŒØ´Ø±ÙØªÙ‡ ${total} Ú©Ø§Ù†ÙÛŒÚ¯...`); const BATCH_SIZE = 50; const startTime = Date.now(); for (let i = 0; i < allConfigs.length; i += BATCH_SIZE) { const batch = allConfigs.slice(i, i + BATCH_SIZE); await Promise.all(batch.map(async (item) => { const { config, protocol, idx, server, port } = item; const resultEl = getEl(`ping-${coreName}-${protocol}-${idx}`); if (!resultEl) return; resultEl.innerHTML = '<span class="loader-mini"></span>'; const result = await tcpPingAdvanced(server, port, protocol, 3); if (result.status === 'Live') { const color = result.latency < 200 ? '#4CAF50' : result.latency < 500 ? '#FFC107' : '#F44336'; const stabilityIcon = result.stability === 'excellent' ? 'ğŸŸ¢' : result.stability === 'good' ? 'ğŸŸ¡' : 'ğŸ”´'; resultEl.innerHTML = `<span style="color: ${color}; font-weight: bold;" title="Avg: ${result.latency}ms | Min: ${result.min}ms | Max: ${result.max}ms | Jitter: ${result.jitter}ms | Stability: ${result.stability}">${stabilityIcon} ${result.latency}ms</span>`; realPingResults[`${coreName}-${protocol}-${idx}`] = result.latency; liveCount++; if (result.stability === 'excellent') excellentCount++; } else { resultEl.innerHTML = '<span style="color: #F44336;" title="ØºÛŒØ±Ù‚Ø§Ø¨Ù„ Ø¯Ø³ØªØ±Ø³">âœ—</span>'; realPingResults[`${coreName}-${protocol}-${idx}`] = 9999; deadCount++; } completed++; const progress = Math.round((completed / total) * 100); const elapsed = Math.round((Date.now() - startTime) / 1000); btn.textContent = `ØªØ³Øª ${progress}% (${completed}/${total}) - ${elapsed}s - Ø²Ù†Ø¯Ù‡: ${liveCount}`; })); } const totalTime = Math.round((Date.now() - startTime) / 1000); btn.disabled = false; btn.innerHTML = `ğŸŒ ØªØ³Øª ÙˆØ§Ù‚Ø¹ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ø§Ø² Ø´Ø¨Ú©Ù‡ Ø´Ù…Ø§ (${total} Ú©Ø§Ù†ÙÛŒÚ¯)`; showToast(`âœ… ØªØ³Øª Ú©Ø§Ù…Ù„ Ø¯Ø± ${totalTime}s | Ø²Ù†Ø¯Ù‡: ${liveCount} | Ø¹Ø§Ù„ÛŒ: ${excellentCount} | Ù…Ø±Ø¯Ù‡: ${deadCount}`); sortConfigsByRealPing(coreName); if (liveCount > 0) { setTimeout(() => { const createSub = confirm(`âœ… ØªØ³Øª ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯!\n\nğŸ“Š Ù†ØªØ§ÛŒØ¬:\nâ€¢ Ø²Ù…Ø§Ù†: ${totalTime} Ø«Ø§Ù†ÛŒÙ‡\nâ€¢ Ú©Ø§Ù†ÙÛŒÚ¯ Ø²Ù†Ø¯Ù‡: ${liveCount}\nâ€¢ Ú©Ø§Ù†ÙÛŒÚ¯ Ø¨Ø§ Ú©ÛŒÙÛŒØª Ø¹Ø§Ù„ÛŒ: ${excellentCount}\nâ€¢ Ú©Ø§Ù†ÙÛŒÚ¯ Ù…Ø±Ø¯Ù‡: ${deadCount}\n\nØ³Ø§Ø¨ Ù„ÛŒÙ†Ú© Ø§Ø² ${Math.min(liveCount, 20)} Ú©Ø§Ù†ÙÛŒÚ¯ Ø¨Ø±ØªØ± Ø¨Ø³Ø§Ø²ÛŒÙ…ØŸ`); if (createSub) { const format = coreName === 'xray' ? 'xray' : 'singbox'; window.generateSubscription(coreName, 'auto', format, 'copy'); } }, 1500); } };
    function sortConfigsByRealPing(coreName) { const wrapper = coreName === 'xray' ? xrayWrapper : singboxWrapper; const protocolGroups = wrapper.querySelectorAll('.protocol-group'); protocolGroups.forEach(group => { const configList = group.querySelector('.config-list'); if (!configList) return; const items = Array.from(configList.querySelectorAll('.config-item')); items.sort((a, b) => { const keyA = a.dataset.configKey; const keyB = b.dataset.configKey; const pingA = realPingResults[keyA] || 9999; const pingB = realPingResults[keyB] || 9999; return pingA - pingB; }); items.forEach(item => configList.appendChild(item)); }); console.log(`ğŸ“Š ${coreName} sorted by real ping (advanced)`); }
    fetchAndRender();
